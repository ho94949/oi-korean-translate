\begin{problem}{광물}
	{standard input}{standard output}
	{1 second}{256 megabytes}{}
	
	JOI교수의 연구실에는, $N$종류의 광물을 연구하고 있다. 연구실에는, 각 종류의 광물이 두 조각씩 있다. 조각은 총 $2N$개가 존재하고, 각 조각에는 1번부터 $2N$번 까지의 번호가 붙어있다.
	
	하지만 어느 날, 조수 비타로는 $2N$개의 광물을 포함한 박스를 떨어뜨려 어떤 조각과 어떤 조각이 같은지 모르게 되어 버렸다. 
	
	연구실은 0개 이상 $2N$개 이하의 조각을 넣으면, 광물이 흡수하는 빛의 파장을 측정하는 것으로, 기계 안에 몇가지 종류의 광물이 들어있는가를 판단하는 장치가 있다. 비타로는 이 장치를 사용해서 $2N$개의 조각에서 같은 종류의 광물 짝 $N$개를 알고싶어 한다. 비타로는, 처음에 기계에 광물을 넣지 않은 상태로부터 시작해, 다음 동작 중 하나를 반복한다.
	
	\begin{itemize}
		\item 기계에 새로운 조각을 하나 집어 넣어서, 기계 안에 몇가지 종류의 광물이 있는지를 알아낸다.
		\item 기계에서 새로운 조각을 하나 빼서, 기계 안에 몇가지 종류의 광물이 있는지를 알아낸다.
	\end{itemize}

	시간이 너무 오래 걸리면 JOI교수에게 들켜버리기 때문에, 비타로는 기계를 최대 1 000 000번만 사용할 수 있다.
	
	광물의 종류가 주어졌을 때, 기계를 사용하여 모든 쌍의 광물을 알아내는 프로그램을 작성하여라.
	
	
	\Specification
	
	당신은 파일 하나를 제출해야 한다.
	
	이 파일의 이름은 \texttt{minerals.cpp}이다. 파일은 다음 함수를 구현해야 한다. 또한, \texttt{minerals.h}를 include해야 한다.
	
	\begin{itemize}
		\item \texttt{void Solve(int N)}
		
		이 함수는 각 테스트 케이스 마다 정확히 한 번 불린다.
		\begin{itemize}
			\item 인자 \texttt{N}은 광물의 수 $N$을 나타낸다.
		\end{itemize}
		
		당신의 프로그램은 다음 함수를 호출 할 수 있다.
		\begin{itemize}
			\item \texttt{int Query(int x)}
			
			이 함수는, 지정된 조각의 번호에 대해서, 이 조각이 이미 기계 안에 들어 있으면 기계에서 빼고, 그렇지 않으면 이 조각을 기계에 넣는다.
						
			\begin{itemize}
				\item 당신은 조각의 번호 $x$를 인자 \texttt{x}를 사용해서 나타내어야 한다. 이 번호는 $1 \le x \le 2N$을 만족해야 한다. 아닌 경우에는, \textbf{오답 [1]}이 된다.
				
				\item 당신은 이 함수를 1 000 000번 이상 호출해서는 안된다. 호출 한 경우에는 \textbf{오답 [2]}이 된다.
			\end{itemize}
			
			\item \texttt{void Answer(int a, int b)}
			
			이 함수를 사용하여, 같은 종류의 광물의 쌍을 답할 수 있다.
			
			\begin{itemize}
				\item 인자 \texttt{a}와 \texttt{b}는 $a$번째 광물과 $b$번째 광물이 같은 종류라는 것을 의미한다. 이 수는 $1 \le a \le 2N$과 $1 \le b \le 2N$을 만족해야 한다. 이것을 만족하지 않을 경우 \textbf{오답 [3]}이 된다. 만약 $a$와 $b$로 주어진 수가 2번 이상 나타날 경우 \textbf{오답 [4]}이 된다. 서로 다른 종류의 광물을 지정할 경우 \textbf{오답 [5]}이 된다.
			\end{itemize}
		
			함수 \text{Answer}는 정확히 $N$번 호출될 필요가 있다. 함수 \texttt{solve}의 실행 종료시에 함수 \texttt{Answer}의 호출 횟수가 $N$번이 아닐 경우 \textbf{오답 [6]}이 된다.
		\end{itemize}
		
	\end{itemize}
	
	\Notes
	
	\begin{itemize}
		\item 당신의 프로그램은 내부에서 사용할 목적으로 함수나 전역변수를 사용할 수 있다.
		\item 당신의 프로그램은 표준 입출력을 사용해서는 안된다. 당신의 프로그램은 어떠한 방법으로도 다른 파일에 접근해서는 안된다. 단, 당신의 프로그램은 디버그 목적으로 표준 에러출력에 출력할 수 있다.
	\end{itemize}
	
	당신은 대회 홈페이지의 아카이브에서 프로그램을 테스트 하기 위한 목적의 샘플 그레이더를 받을 수 있다. 아카이브는 당신의 프로그램의 예제 소스 또한 첨부되어 있다.
	샘플 그레이더는 파일 \texttt{grader.cpp}이다. 당신의 프로그램을 테스트 하기 위해서, \texttt{grader.cpp}, \texttt{minerals.cpp}, \texttt{minerals.h}를 같은 디렉토리 안에 놓고, 컴파일 하기 위해 다음 커맨드를 실행하여라.
	
	\begin{itemize}
		\item \texttt{g++ -std=gnu++14 -O2 -o grader grader.cpp minerals.cpp}
	\end{itemize}
	
	컴파일이 성공적이면, 파일 \texttt{grader}가 생성된다.
	
	실제 그레이더와 샘플 그레이더는 다름에 주의하여라. 샘플 그레이더는 하나의 프로세스에서 실행 되며, 입력을 표준 입력으로 부터 받고, 출력을 표준 출력에 출력한다.
	
	\InputFile
	
	샘플 그레이더는 표준 입력에서 다음과 같은 형식으로 입력받는다.
	
	$N$
	
	$X_1$ $Y_1$
	
	$\cdots$
	
	$X_N$ $Y_N$
		
	$X_i$와 $Y_i$ ($0 \le i \le N-2$)는 $X_i$번 조각과 $Y_i$번 조각이 같은 종류의 광물임을 의미한다.
	
	\OutputFile
	
	프로그램이 정상적으로 종료되었다면, 샘플 그레이더는 다음과 같은 정보를 표준 출력에 출력한다. (따옴표는 출력하지 않는다.)
	
	\begin{itemize}
		\item 정답으로 판단 된 경우, \texttt{Query}함수의 호출 횟수를 ``\texttt{Accepted: 100}"과 같은 형식으로 출력한다.
		\item 오답으로 판단 된 경우, 오답의 종류를 ``\texttt{Wrong Answer [1]}"과 같은 형식으로 출력한다.
	\end{itemize}
	
	프로그램이 다양한 오답의 종류에 속해 있을 경우, 샘플 그레이더는 그 중 하나만 출력 할 것이다.
	
	\Constraints
	
	모든 입력 데이터는 다음의 조건을 만족한다. 샘플 그레이더의 $X_i$와 $Y_i$의 정의에 따라서
	
	\begin{itemize}
		\item $1 \le N \le 43\ 000$.
		\item $1 \le X_i \le 2N$ ($1 \le i \le N$).
		\item $1 \le Y_i \le 2N$ ($1 \le i \le N$).
		\item $X_i \ne X_j $ ($1 \le i < j \le N$).
		\item $Y_i \ne Y_j $ ($1 \le i < j \le N$).
		\item $X_i \ne Y_j$ ($1 \le i \le N$, $1 \le j \le N$).
		\item $0 \le A_i < B_i \le N-1$. ($0 \le i \le N-2$)
		\item 몇 개의 다리를 사용하면 어떠한 두 섬을 오가는것도 가능하다.
		\item 각 섬 마다, 섬에 직접 연결된 다리는 최대 18개 이다.
	\end{itemize}
	
	\SubtaskWithCost{1}{6}
	\begin{itemize}
		\item $N \le 100$.
	\end{itemize}
	
	\SubtaskWithCost{2}{25}
	\begin{itemize}
		\item $N \le 15\ 000$.
		\item $1 \le X_i \le N$ ($1 \le i \le N$).
		\item $N+1 \le Y_i \le 2N$ ($1 \le i\le N$).
	\end{itemize}
	
	\SubtaskWithCost{3}{9}
	\begin{itemize}
		\item $N \le 15\ 000$
	\end{itemize}

	\SubtaskWithCost{4}{30}
	\begin{itemize}
		\item $N \le 38\ 000$
	\end{itemize}
	
	\SubtaskWithCost{5}{5}
	\begin{itemize}
		\item $N \le 39\ 000$
	\end{itemize}
	
	\SubtaskWithCost{6}{5}
	\begin{itemize}
		\item $N \le 40\ 000$
	\end{itemize}
	
	\SubtaskWithCost{7}{5}
	\begin{itemize}
		\item $N \le 41\ 000$
	\end{itemize}
	
	\SubtaskWithCost{8}{5}
	\begin{itemize}
		\item $N \le 42\ 000$
	\end{itemize}
	
	
	\SubtaskWithCost{9}{10}
	
	추가 제한조건이 없다.
	
	\Examples
	
	이 함수는 그레이더의 예제 입력과 해당하는 함수 호출을 보여준다.
	
	\begin{tabular}{|l|l|l|l|}
		\hline
		\multirow{2}{*}{예제 입력}                                                             & \multicolumn{3}{l|}{예제 함수 호출}    \\ \cline{2-4} 
		& 호출       & 호출             & 반환값  \\ \hline
		\multirow{9}{*}{\begin{tabular}[c]{@{}l@{}}\texttt{4}\\ \texttt{1 2}\\ \texttt{2 6}\\ \texttt{3 4}\\ \texttt{7 8}\end{tabular}} & \texttt{Solve(4)} &                &      \\ \cline{2-4} 
		&          & \texttt{Query(1)} & \texttt{1}    \\ \cline{2-4} 
		&          & \texttt{Query(2)} & \texttt{2}    \\ \cline{2-4} 
		&          & \texttt{Query(5)} & \texttt{2}    \\ \cline{2-4} 
		&          & \texttt{Query(2)} & \texttt{1}    \\ \cline{2-4} 
		&          & \texttt{Answer(3, 4)}   & (없음) \\ \cline{2-4} 
		&          & \texttt{Answer(5, 1)}   & (없음) \\ \cline{2-4} 
		&          & \texttt{Answer(8, 7)}   & (없음) \\ \cline{2-4} 
		&          & \texttt{Answer(2, 6)}   & (없음) \\ \hline
	\end{tabular}
\end{problem}
