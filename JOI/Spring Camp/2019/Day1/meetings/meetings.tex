\begin{problem}{비버의 모임}
	{standard input}{standard output}
	{2초}{256MB}{}
	
	0부터 $N-1$까지의 번호가 붙은 비버가 사는 $N$ 개의 섬이 있다. 각 섬은 $N-1$ 개의 양방향으로 연결되는 다리로 연결되어 있다. 몇 개의 다리를 사용하면 어떠한 두 섬을 오가는 것도 가능하다. \textbf{각 섬마다, 섬에 직접 연결된 다리는 최대 18개이다.} 각 섬에는 비버가 살고 있다.
	
	가끔, 몇몇 비버는 특정 섬에서 모임을 한다. 세 비버가 만날 때 그들은 다음과 같은 조건을 만족하는 섬에서 만난다:
	
	\begin{itemize}
	\item 모임을 할 때 3마리의 비버가 자신이 살고 있는 섬부터 이동할 때 사용하는 다리의 수의 합이 최소가 되는 섬 (이런 섬은 유일하게 존재한다.)
	\end{itemize}
	
	이 섬은 3마리의 비버 중 하나가 사는 섬일 수 있음에 주의하여라.
	
	당신은 $N$ 개의 섬이 어떤 방식으로 다리로 연결되어 있는지가 궁금해졌다. 당신은 직접 이 섬을 확인할 수 없다. 그렇기 때문에, 당신은 비버에게 명령을 내리기로 했다. 명령은 다음과 같다.
	
	\begin{itemize}
		\item 세 개의 섬 $u$, $v$, $w$ ($0 \le u \le N-1,\ 0 \le v \le N-1, \ 0 \le w \le N-1, \ u \ne v, \ u \ne w , v \ne w$)을 지정하고 $u$, $v$, $w$에 사는 비버끼리 모임을 하게 한다.
		\item 비버가 모임을 하는 섬을 알 수 있다.
	\end{itemize}

	당신은 섬이 어떤 방식으로 다리로 연결되어 있는지를 적은 수의 명령으로 알고 싶다. 섬의 수와 비버와 통신하는 방법이 주어졌을 때, 섬이 연결된 방식을 알아내어라.
	
	
	\Specification
	
	당신은 파일 하나를 제출해야 한다.
	
	이 파일의 이름은 \texttt{meetings.cpp}이다. 파일은 다음 함수를 구현해야 한다. 또한, \texttt{meetings.h}를 include해야 한다.
	
	\begin{itemize}
		\item \texttt{void Solve(int N)}
		
		이 함수는 각 테스트 케이스마다 정확히 한 번 불린다.
		\begin{itemize}
			\item 인자 \texttt{N}은 섬의 수 $N$을 나타낸다.
		\end{itemize}
	
		당신의 프로그램은 다음 함수를 호출 할 수 있다.
		\begin{itemize}
			\item \texttt{int Query(int u, int v, int w)}
			
			이 함수는 주어진 세 개의 섬에 대해서 세 비버가 만나는 섬의 번호를 반환한다.
			
			\begin{itemize}
				\item 당신은 섬의 번호 $u$, $v$, $w$를 인자 \texttt{u}, \texttt{v}, \texttt{w}를 사용해서 나타내어야 한다. 이 번호는 $0 \le u \le N-1,\ 0 \le v \le N-1, \ 0 \le w \le N-1, \ u \ne v, \ u \ne w , v \ne w$을 모두 만족해야 한다. 아닌 경우에는 \textbf{오답 [1]}이 된다.
				
				\item 당신은 이 함수를 100 000번 이상 호출해서는 안 된다. 호출 한 경우에는 \textbf{오답 [2]}이 된다.
			\end{itemize}
		
			\item \texttt{void Bridge(int u, int v)}
			
			이 함수는 섬이 다리로 연결되어 있는지에 대한 정보를 답할 수 있다.
			
			\begin{itemize}
				\item 인자 \texttt{u}와 \texttt{v}는 섬 $u$와 섬 $v$가 다리로 서로 직접 연결되어있다는 것을 나타낸다.
				\item $0 \le u < v \le N-1$이 아닌 경우, \textbf{오답 [3]}이 된다.
				\item 섬 $u$와 $v$가 직접 다리로 연결되어있지 않으면 \textbf{오답 [4]}이 된다.
				\item 함수가 같은 인자 \texttt{u}, \texttt{v}를 여러 번 호출한 경우 \textbf{오답 [5]}이 된다.
				\item \texttt{N-1}개의 다리가 있으므로, 함수는 정확히 \texttt{N-1}번 호출되어야 한다. 만약 함수 \texttt{Solve}가 끝날 때 이 함수의 호출 횟수가 $\texttt{N-1}$이 아니면 \textbf{오답 [6]}이 된다.
			\end{itemize}
		\end{itemize}
	
	
	\end{itemize}

	\Notes

	\begin{itemize}
		\item 당신의 프로그램은 내부에서 사용할 목적으로 함수나 전역변수를 사용할 수 있다.
		\item 당신의 프로그램은 표준 입출력을 사용해서는 안 된다. 당신의 프로그램은 어떠한 방법으로도 다른 파일에 접근해서는 안 된다. 단, 당신의 프로그램은 디버그 목적으로 표준 에러출력에 출력할 수 있다.
	\end{itemize}

	당신은 대회 홈페이지의 아카이브에서 프로그램을 테스트 하기 위한 목적의 샘플 그레이더를 받을 수 있다. 아카이브는 당신의 프로그램의 예제 소스 또한 첨부되어 있다.
	샘플 그레이더는 파일 \texttt{grader.cpp}이다. 당신의 프로그램을 테스트하기 위해서, \texttt{grader.cpp}, \texttt{meetings.cpp}, \texttt{meetings.h}를 같은 디렉토리 안에 놓고, 컴파일하기 위해 다음 커맨드를 실행하여라.
	
	\begin{itemize}
		\item \texttt{g++ -std=gnu++14 -O2 -o grader grader.cpp meetings.cpp}
	\end{itemize}
	
	컴파일이 성공적이면, 파일 \texttt{grader}가 생성된다.
	
	실제 그레이더와 샘플 그레이더는 다름에 주의하여라. 샘플 그레이더는 하나의 프로세스에서 실행되며, 입력을 표준 입력으로부터 받고, 출력을 표준 출력에 출력한다.
	
	\InputFile
	
	샘플 그레이더는 표준 입력에서 다음과 같은 형식으로 입력받는다.
	
	$N$
	
	$A_0$ $B_0$
	
	$\vdots$
	
	$A_{N-2}$ $B_{N-2}$
	
	$A_i$와 $B_i$ ($0 \le i \le N-2$)는 섬 $A_i$와 $B_i$가 다리로 직접 연결되어있다는 것을 의미한다.
	
	\OutputFile
	
	프로그램이 정상적으로 종료되었다면, 샘플 그레이더는 다음과 같은 정보를 표준 출력에 출력한다. (따옴표는 출력하지 않는다.)
	
	\begin{itemize}
		\item 정답으로 판단된 경우, \texttt{Query}함수의 호출 횟수를 ``\texttt{Accepted: 100}"과 같은 형식으로 출력한다.
		\item 오답으로 판단된 경우, 오답의 종류를 ``\texttt{Wrong Answer [1]}"과 같은 형식으로 출력한다.
	\end{itemize}
	
	프로그램이 다양한 오답의 종류에 속해 있으면, 샘플 그레이더는 그중 하나만 출력할 것이다.
	
	\Constraints
	
	샘플 그레이더의 $A_i$와 $B_i$의 정의에 따라서
	
	\begin{itemize}
		\item $3 \le M \le 2\ 000$.
		\item $0 \le A_i < B_i \le N-1$. ($0 \le i \le N-2$)
		\item 몇 개의 다리를 사용하면 어떠한 두 섬을 오가는 것도 가능하다.
		\item 각 섬마다, 섬에 직접 연결된 다리는 최대 18개이다.
	\end{itemize}
	
	


	\SubtaskWithCost{1}{7}
	\begin{itemize}
		\item $N \le 7$
	\end{itemize}
	
	\SubtaskWithCost{2}{10}
	\begin{itemize}
		\item $N \le 50$
	\end{itemize}
	
	\SubtaskWithCost{3}{12}
	\begin{itemize}
		\item $N \le 300$
	\end{itemize}
	
	
	\SubtaskWithCost{4}{71}
	
	추가 제한조건이 없다.
	
	\begin{itemize}
		\item 서브태스크 1, 2, 3에 대해서, 서브태스크 안에 있는 모든 테스트 케이스를 맞춘 경우 점수를 준다.
		\item 서브태스크 4에 대해서, $X$를 \texttt{Query}함수의 최대 호출횟수라고 하자.
		\begin{itemize}
			\item $40\ 000 < X \le 100\ 000$이면 49점을 받는다.
			\item $X \le 40\ 000$이면 71점을 받는다.
		\end{itemize}
	\end{itemize}
	
	\Examples
	
	이 함수는 그레이더의 예제 입력과 해당하는 함수 호출을 보여준다.
	
	\begin{tabular}{|l|l|l|l|}
		\hline
		\multirow{2}{*}{예제 입력}                                                             & \multicolumn{3}{l|}{예제 함수 호출}    \\ \cline{2-4} 
		& 호출       & 호출             & 반환값  \\ \hline
		\multirow{7}{*}{\begin{tabular}[c]{@{}l@{}}\texttt{5}\\ \texttt{0 1}\\ \texttt{0 2}\\ \texttt{1 3}\\ \texttt{1 4}\end{tabular}} & \texttt{Solve(5)} &                &      \\ \cline{2-4} 
		&          & \texttt{Query(0, 1, 2)} & \texttt{0}    \\ \cline{2-4} 
		&          & \texttt{Query(0, 3, 4)} & \texttt{1}    \\ \cline{2-4} 
		&          & \texttt{Bridge(1, 3)}   & (없음) \\ \cline{2-4} 
		&          & \texttt{Bridge(0, 2)}   & (없음) \\ \cline{2-4} 
		&          & \texttt{Bridge(1, 4)}   & (없음) \\ \cline{2-4} 
		&          & \texttt{Bridge(0, 1)}   & (없음) \\ \hline
	\end{tabular}
\end{problem}

