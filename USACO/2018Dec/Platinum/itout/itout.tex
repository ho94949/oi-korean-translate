\begin{problem}{정리하자}
	{itout.in}{itout.out}
	{2 seconds}{512 megabytes}{}
	
	농부 존은 $1 \cdots N$의 번호가 붙은 일렬로 서 있는 $N$마리의 소를 가지고 있다. ($1 \le N \le 10^5$)

	농부 존은 소가 증가하는 순서대로 정렬되기를 원하지만, 현재는 정리가 되어있지 않다. 예전에 농부 존은 놀라운 ``버블정렬" 알고리즘을 사용하여 소를 정렬했지만, 오늘은 귀찮다고 생각한다. 한번에 하나씩 특정한 소를 불러 정렬 할 것이다. 어떤 소가 불렸을 때, 그 소는 (자신의 관점에서) 정리가 되도록 움직일 것이다. 그 소의 오른쪽에 있는 소의 번호가 더 작아질 때 까지, 오른쪽에 있는 소와 자리를 바꿀 것이다. 그 후, 왼쪽에 있는 소의 번호가 더 커질 때 까지, 왼쪽에 있는 소와 자리를 바꿀 것이다. 최종적으로, 소는 정리되었다. 그 소의 입장에서는 왼쪽에 있는 소가 작은 번호를, 오른쪽에 있는 소가 큰 번호를 가진다.

	농부 존은 어떤 소의 부분집합을 골라서, 이 부분집합을 차례대로 보면서 (번호가 증가하는 순서로) 소를 불러 $N$마리의 소가 정리될 때 까지 반복할 것이다. 예를 들어, 번호 $\{2, \ 4, \ 5\}$번 소를 부분집합으로 고르면, 2번 소를 부르고, 4번 소를 부르고, 5번 소를 부를 것이다. $N$마리의 소가 정렬되지 않았다면, 같은 소에게 계속 계속 반복해서 부를 것이다.

	농부 존은 어떤 소들이 집중하는지 모르기 때문에, 이 부분집합의 크기를 최소로 하고 싶다. 그리고 농부 존은 $K$가 행운의 숫자라고 생각 하고 있다. 소가 최종적으로 모두 정렬되어있게 하는 크기가 최소인 부분집합 중 사전순으로 $K$ 번째 집합을 찾아라.

	집합 $S$가 $T$보다 작기 위해서는, $S$와 $T$의 원소들을 오름차순으로 정렬 했을 때, 정렬된 두 수열에 대해서, $S$를 정렬한 수열이 사전순으로 작다는 의미이다. 예를 들어, $\{1,\ 3,\ 6\}$ 은 $\{1, \ 4,\ 5\}$ 보다 사전순으로 작다.

	\Scoring

	$3/16$의 점수에 해당하는 데이터에서는 $N \le 6$이고 $K=1$ 이다.
	
	추가되는 $5/16$의 점수에 해당하는 데이터에서는 $K=1$ 이다.
	
	추가되는 $8/16$의 점수에 해당하는 데이터에서는 추가 제한조건이 없다.
	
	\InputFile

	첫째 줄에는 정수 $N$이 주어진다. 둘째 줄에는 정수 $K$ ($1 \le K \le 10^{18}$) 이 주어진다. 셋째 줄에는 $N$개의 공백으로 구분된 정수가 주어지고, 왼쪽부터 오른쪽 까지 소의 번호가 주어진다.

	적어도 $K$개의 올바른 부분집합이 존재함이 보장된다.
	
	\OutputFile
	
	첫째 줄에는 최소 크기 부분집합의 크기를 출력해야 한다.
	다음 부터 사전순으로 $K$번째 최소 집합을 번호가 증가하는 순서대로 한 줄에 하나씩 출력해야 한다.

	\Constraints
		
	\begin{example}
	\exmp{
4 1
4 2 1 3
	}{%
2
1
4
	}%
	\end{example}
	
	\Notes

	배열 4 2 1 3으로 시작한다. 농부 존이 1번 소를 부른 이후로 배열은 1 4 2 3이 된다. 4번 소를 부른 이후에 배열은 1 2 3 4 가 되고, 정렬되었다.
	
	
\end{problem}

